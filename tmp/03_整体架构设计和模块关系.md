# DeerFlow 整体架构设计和模块关系详解

## 一、架构设计概述

### 1.1 设计理念

DeerFlow 采用**分层架构 + 多智能体协作**的设计模式，核心设计理念包括：

**核心原则：**
- **模块化设计** - 各模块职责清晰，低耦合高内聚
- **可扩展性** - 支持自定义智能体、工具、LLM 提供商
- **状态驱动** - 基于 LangGraph 的状态机管理工作流
- **工具抽象** - 统一的工具接口，易于集成新能力
- **配置驱动** - 通过配置文件控制行为，无需修改代码

**架构特点：**
- 前后端分离架构
- 基于 LangGraph 的工作流引擎
- 插件化的工具系统
- 多 LLM 提供商统一接口
- 支持多种持久化后端

---

## 二、整体架构层次

### 2.1 架构分层图

```
┌─────────────────────────────────────────────────────────────┐
│                      用户交互层 (User Interface)              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │  CLI 命令行   │  │  Web 前端     │  │  HTTP API    │      │
│  │  (main.py)   │  │  (Next.js)   │  │  (FastAPI)   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                    应用服务层 (Application Layer)             │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              Web 服务 (src/server/)                   │   │
│  │  • chat_stream.py - 聊天流式处理                      │   │
│  │  • routes.py - API 路由定义                           │   │
│  │  • websocket.py - WebSocket 连接                     │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  工作流引擎层 (Workflow Engine)               │
│  ┌──────────────────────────────────────────────────────┐   │
│  │            LangGraph 工作流 (src/graph/)              │   │
│  │  • builder.py - 构建工作流图                          │   │
│  │  • nodes.py - 定义工作流节点                          │   │
│  │  • types.py - 状态类型定义                            │   │
│  │  • checkpointer.py - 检查点管理                       │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                   智能体层 (Agent Layer)                      │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              智能体系统 (src/agents/)                  │   │
│  │  • agents.py - 智能体定义和配置                        │   │
│  │  • Coordinator - 协调器                               │   │
│  │  • Planner - 规划器                                   │   │
│  │  • Researcher - 研究员                                │   │
│  │  • Coder - 编码员                                     │   │
│  │  • Analyst - 分析员                                   │   │
│  │  • Reporter - 报告生成器                              │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                    工具层 (Tool Layer)                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  搜索工具    │  │  爬虫工具    │  │  代码执行    │         │
│  │ (search.py) │  │(crawler.py) │  │(python.py)  │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  RAG 工具    │  │  MCP 工具    │  │  TTS 工具    │         │
│  │  (rag.py)   │  │  (mcp.py)   │  │  (tts.py)   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│                  基础设施层 (Infrastructure)                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  LLM 集成    │  │  向量数据库  │  │  持久化存储  │         │
│  │  (llms/)    │  │   (rag/)    │  │(checkpointer)│        │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  配置管理    │  │  日志系统    │  │  监控指标    │         │
│  │ (config.py) │  │ (logging)   │  │ (metrics)   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 数据流向图

```
用户输入
    ↓
[Web/CLI] 接收请求
    ↓
[Server] 创建会话和状态
    ↓
[Graph Builder] 构建工作流图
    ↓
[Workflow Engine] 执行状态机
    ↓
[Agents] 调用智能体
    ↓
[Tools] 执行具体工具
    ↓
[LLM/RAG/Search] 外部服务调用
    ↓
[State] 更新共享状态
    ↓
[Checkpointer] 保存检查点（可选）
    ↓
[Reporter] 生成最终报告
    ↓
[Server] 流式返回结果
    ↓
用户接收输出
```

---

## 三、核心模块详解

### 3.1 工作流引擎模块 (src/graph/)

**职责：** 构建和管理整个研究流程的状态机

**核心文件：**

#### 3.1.1 builder.py - 工作流构建器

```python
# 核心功能：构建 LangGraph 工作流图
def create_research_graph(config: Config) -> CompiledGraph:
    """
    构建研究工作流图

    节点包括：
    - clarification_node: 澄清节点
    - background_investigation_node: 背景调查节点
    - planning_node: 规划节点
    - human_review_node: 人工审核节点
    - research_node: 研究执行节点
    - reporting_node: 报告生成节点

    边包括：
    - 条件边：根据状态决定下一步
    - 普通边：固定的流程转换
    """
    workflow = StateGraph(ResearchState)

    # 添加节点
    workflow.add_node("clarification", clarification_node)
    workflow.add_node("background", background_investigation_node)
    workflow.add_node("planning", planning_node)
    workflow.add_node("research", research_node)
    workflow.add_node("reporting", reporting_node)

    # 添加边和条件路由
    workflow.add_conditional_edges(
        "clarification",
        should_continue_clarification,
        {
            "continue": "clarification",
            "done": "background"
        }
    )

    # 编译图
    return workflow.compile(checkpointer=checkpointer)
```

**关键概念：**
- **StateGraph** - LangGraph 的状态图类
- **节点 (Node)** - 执行具体逻辑的函数
- **边 (Edge)** - 节点之间的转换关系
- **条件边** - 根据状态动态决定下一个节点
- **检查点** - 保存状态以支持中断恢复

#### 3.1.2 nodes.py - 工作流节点实现

```python
# 每个节点都是一个函数，接收状态并返回更新后的状态

def clarification_node(state: ResearchState) -> ResearchState:
    """澄清节点：明确用户意图"""
    # 1. 检查是否需要澄清
    # 2. 生成澄清问题
    # 3. 等待用户回答
    # 4. 更新查询
    return updated_state

def background_investigation_node(state: ResearchState) -> ResearchState:
    """背景调查节点：初步搜索"""
    # 1. 执行搜索
    # 2. 提取关键信息
    # 3. 构建上下文
    return updated_state

def planning_node(state: ResearchState) -> ResearchState:
    """规划节点：生成研究计划"""
    # 1. 调用 Planner 智能体
    # 2. 解析计划结构
    # 3. 验证计划
    return updated_state

def research_node(state: ResearchState) -> ResearchState:
    """研究节点：执行研究步骤"""
    # 1. 遍历计划步骤
    # 2. 根据类型选择智能体
    # 3. 执行并收集结果
    return updated_state

def reporting_node(state: ResearchState) -> ResearchState:
    """报告节点：生成最终报告"""
    # 1. 整合所有结果
    # 2. 调用 Reporter 智能体
    # 3. 格式化输出
    return updated_state
```

**节点设计原则：**
- 每个节点职责单一
- 节点之间通过状态通信
- 节点可以调用智能体和工具
- 节点应该是幂等的（支持重试）

#### 3.1.3 types.py - 状态类型定义

```python
from typing import TypedDict, List, Dict, Optional
from langchain_core.messages import BaseMessage

class ResearchState(TypedDict):
    """研究工作流的状态定义"""

    # 输入
    query: str                          # 用户查询
    messages: List[BaseMessage]         # 对话历史

    # 配置
    config: Dict                        # 运行时配置

    # 中间状态
    clarification_done: bool            # 澄清完成
    background_info: Optional[str]      # 背景信息
    research_plan: Optional[Dict]       # 研究计划
    plan_approved: bool                 # 计划审核状态
    current_step: int                   # 当前步骤

    # 研究结果
    research_results: List[Dict]        # 各步骤结果
    sources: List[str]                  # 引用来源
    artifacts: List[str]                # 生成的文件

    # 输出
    final_report: Optional[str]         # 最终报告
    report_metadata: Optional[Dict]     # 报告元数据

    # 错误处理
    errors: List[str]                   # 错误列表
    retry_count: int                    # 重试次数
```

**状态设计要点：**
- 包含所有节点需要的信息
- 支持序列化（用于检查点）
- 类型安全（TypedDict）
- 可扩展（Optional 字段）

---

### 3.2 智能体模块 (src/agents/)

**职责：** 定义和配置各类智能体及其能力

#### 3.2.1 智能体架构

```
智能体基类 (BaseAgent)
    ↓
┌───────────────┬───────────────┬───────────────┐
│               │               │               │
Coordinator   Planner      Research Team    Reporter
(协调器)      (规划器)     (研究团队)       (报告器)
                              ↓
                    ┌─────────┼─────────┐
                    │         │         │
                Researcher  Coder   Analyst
                (研究员)   (编码员) (分析员)
```

#### 3.2.2 agents.py - 智能体定义

```python
# 智能体配置结构
def create_researcher_agent(llm, tools):
    """
    创建研究员智能体

    能力：
    - 网络搜索
    - 网页爬取
    - RAG 检索
    - 信息提取
    """
    return create_react_agent(
        llm=llm,
        tools=[search_tool, crawler_tool, rag_tool],
        prompt=RESEARCHER_PROMPT
    )

def create_coder_agent(llm, tools):
    """
    创建编码员智能体

    能力：
    - Python 代码执行
    - 数据分析
    - 可视化生成
    - 数学计算
    """
    return create_react_agent(
        llm=llm,
        tools=[python_repl_tool],
        prompt=CODER_PROMPT
    )

def create_analyst_agent(llm):
    """
    创建分析员智能体

    能力：
    - 信息综合
    - 逻辑推理
    - 结论提取
    """
    return create_react_agent(
        llm=llm,
        tools=[],  # 无特定工具，纯推理
        prompt=ANALYST_PROMPT
    )
```

**智能体特点：**
- 基于 ReAct 模式（Reasoning + Acting）
- 每个智能体有专属的工具集
- 通过提示词定义行为
- 支持工具调用和多轮推理

---

### 3.3 工具模块 (src/tools/)

**职责：** 提供智能体可调用的各类工具能力

#### 3.3.1 工具分类

```
工具层 (src/tools/)
    ├── 搜索工具 (search/)
    │   ├── tavily.py - Tavily 搜索
    │   ├── infoquest.py - InfoQuest 搜索
    │   ├── duckduckgo.py - DuckDuckGo 搜索
    │   └── arxiv.py - Arxiv 学术搜索
    │
    ├── 爬虫工具 (crawler/)
    │   ├── jina.py - Jina Reader
    │   └── infoquest_crawler.py - InfoQuest 爬虫
    │
    ├── RAG 工具 (rag/)
    │   ├── milvus.py - Milvus 向量检索
    │   ├── qdrant.py - Qdrant 向量检索
    │   └── ragflow.py - RAGFlow 集成
    │
    ├── 代码执行 (code/)
    │   └── python_repl.py - Python REPL
    │
    ├── MCP 工具 (mcp/)
    │   └── mcp_tools.py - MCP 服务器集成
    │
    └── 其他工具
        ├── tts.py - 语音合成
        └── image_gen.py - 图像生成
```

#### 3.3.2 工具接口设计

```python
from langchain_core.tools import BaseTool
from typing import Optional, Type
from pydantic import BaseModel, Field

class SearchInput(BaseModel):
    """搜索工具输入模型"""
    query: str = Field(description="搜索查询")
    max_results: int = Field(default=5, description="最大结果数")

class SearchTool(BaseTool):
    """搜索工具基类"""
    name: str = "search"
    description: str = "搜索网络信息"
    args_schema: Type[BaseModel] = SearchInput

    def _run(self, query: str, max_results: int = 5) -> str:
        """同步执行"""
        # 实现搜索逻辑
        pass

    async def _arun(self, query: str, max_results: int = 5) -> str:
        """异步执行"""
        # 实现异步搜索逻辑
        pass
```

**工具设计原则：**
- 继承 LangChain 的 BaseTool
- 使用 Pydantic 定义输入模型
- 提供清晰的描述（供 LLM 理解）
- 支持同步和异步执行
- 统一的错误处理

---

## 四、模块间依赖关系

### 4.1 依赖关系图

```
┌─────────────┐
│   main.py   │ (入口)
└──────┬──────┘
       │
       ↓
┌─────────────────────────────────────┐
│         src/graph/builder.py         │ (工作流构建)
└──────┬──────────────────────────────┘
       │
       ├─→ src/graph/nodes.py (节点实现)
       │       ↓
       │   ┌───────────────────────┐
       │   │   src/agents/agents.py │ (智能体)
       │   └───────┬───────────────┘
       │           │
       │           ├─→ src/tools/ (工具)
       │           │       ↓
       │           │   ┌──────────────┐
       │           │   │  src/llms/   │ (LLM)
       │           │   └──────────────┘
       │           │
       │           └─→ src/prompts/ (提示词)
       │
       └─→ src/graph/types.py (状态定义)
       └─→ src/graph/checkpointer.py (检查点)
               ↓
           ┌──────────────┐
           │  持久化后端   │ (MongoDB/PostgreSQL)
           └──────────────┘
```

### 4.2 模块依赖说明

**核心依赖链：**
1. **main.py** → **graph/builder.py**
   - 入口程序调用工作流构建器

2. **graph/builder.py** → **graph/nodes.py**
   - 构建器使用节点函数构建图

3. **graph/nodes.py** → **agents/agents.py**
   - 节点调用智能体执行任务

4. **agents/agents.py** → **tools/** + **llms/**
   - 智能体使用工具和 LLM

5. **agents/agents.py** → **prompts/**
   - 智能体使用提示词模板

**横向依赖：**
- **server/** → **graph/builder.py**
  - Web 服务调用工作流引擎

- **tools/** → **llms/**
  - 某些工具需要 LLM（如 RAG）

- **graph/checkpointer.py** → **持久化后端**
  - 检查点管理器依赖存储系统

**配置依赖：**
- 所有模块 → **config.py**
  - 统一的配置管理

---

## 五、关键交互流程

### 5.1 智能体与工具的交互

```
┌──────────────┐
│  Researcher  │ (智能体)
│   Agent      │
└──────┬───────┘
       │
       │ 1. 决定使用工具
       ↓
┌──────────────┐
│  Tool Call   │ (工具调用)
│  {           │
│   "tool": "search",
│   "input": {"query": "..."}
│  }           │
└──────┬───────┘
       │
       │ 2. 执行工具
       ↓
┌──────────────┐
│ Search Tool  │ (搜索工具)
└──────┬───────┘
       │
       │ 3. 调用外部 API
       ↓
┌──────────────┐
│  Tavily API  │ (外部服务)
└──────┬───────┘
       │
       │ 4. 返回结果
       ↓
┌──────────────┐
│ Tool Result  │
│ {            │
│   "results": [...]
│ }            │
└──────┬───────┘
       │
       │ 5. 智能体处理结果
       ↓
┌──────────────┐
│  Researcher  │
│  继续推理     │
└──────────────┘
```

### 5.2 状态在节点间的传递

```
初始状态
{
  "query": "What is quantum computing?",
  "messages": [],
  "research_plan": null,
  ...
}
    ↓
[Clarification Node]
    ↓
更新后状态
{
  "query": "Explain quantum computing principles and applications",
  "clarification_done": true,
  ...
}
    ↓
[Background Investigation Node]
    ↓
更新后状态
{
  "background_info": "Quantum computing uses quantum bits...",
  "search_results": [...],
  ...
}
    ↓
[Planning Node]
    ↓
更新后状态
{
  "research_plan": {
    "steps": [...]
  },
  ...
}
    ↓
继续传递...
```

**状态传递特点：**
- 不可变更新（创建新状态对象）
- 增量更新（只修改变化的字段）
- 类型安全（TypedDict 约束）
- 可序列化（支持检查点）

---

## 六、LLM 集成模块 (src/llms/)

### 6.1 多 LLM 提供商架构

**职责：** 统一管理多个 LLM 提供商，提供统一的调用接口

```
LLM 管理层
    ↓
┌─────────────────────────────────────────────────┐
│           LiteLLM 统一接口层                     │
│  (支持 100+ 模型提供商的统一调用)                 │
└─────────────────────────────────────────────────┘
    ↓
┌────────┬────────┬────────┬────────┬────────┐
│ OpenAI │DeepSeek│ Google │ Azure  │ Qwen   │
│        │        │ Gemini │ OpenAI │        │
└────────┴────────┴────────┴────────┴────────┘
┌────────┬────────┬────────┬────────┬────────┐
│ Claude │ Ollama │Groq    │Together│ 其他   │
│        │(本地)  │        │        │        │
└────────┴────────┴────────┴────────┴────────┘
```

### 6.2 LLM 配置结构

```yaml
# conf.yaml 中的 LLM 配置
LLM_MODELS:
  # 基础模型（用于大部分任务）
  basic:
    provider: openai
    model: gpt-4o
    api_key: ${OPENAI_API_KEY}
    temperature: 0.7
    max_tokens: 4096

  # 高级模型（用于复杂推理）
  advanced:
    provider: anthropic
    model: claude-3-5-sonnet-20241022
    api_key: ${ANTHROPIC_API_KEY}
    temperature: 0.5

  # 经济模型（用于简单任务）
  cheap:
    provider: deepseek
    model: deepseek-chat
    api_key: ${DEEPSEEK_API_KEY}
    temperature: 0.7
```

### 6.3 LLM 调用流程

```
智能体需要 LLM
    ↓
查询配置文件
    ↓
选择合适的模型
    ↓
通过 LiteLLM 调用
    ↓
┌─────────────────┐
│  重试机制        │
│  - 指数退避      │
│  - 最多 3 次     │
└─────────────────┘
    ↓
┌─────────────────┐
│  降级策略        │
│  - 主模型失败    │
│  - 切换备用模型  │
└─────────────────┘
    ↓
返回结果给智能体
```

---

## 七、提示词管理模块 (src/prompts/)

### 7.1 提示词架构

**职责：** 集中管理所有智能体的提示词模板

```
src/prompts/
    ├── coordinator.py - 协调器提示词
    ├── planner.py - 规划器提示词
    ├── researcher.py - 研究员提示词
    ├── coder.py - 编码员提示词
    ├── analyst.py - 分析员提示词
    ├── reporter.py - 报告生成器提示词
    └── clarification.py - 澄清提示词
```

### 7.2 提示词设计模式

```python
# 典型的提示词结构
RESEARCHER_PROMPT = """
你是一个专业的研究员，负责搜索和收集信息。

## 你的能力
- 使用搜索引擎查找信息
- 爬取网页内容
- 从知识库检索相关信息

## 你的任务
{task_description}

## 上下文信息
{context}

## 可用工具
{tools}

## 输出要求
- 提供准确的信息
- 标注信息来源
- 如果信息不确定，明确说明
"""
```

### 7.3 提示词与智能体的绑定

```
Planner Agent ←→ planner.py
    ↓
生成研究计划的提示词
包含：
- 角色定义
- 任务说明
- 输出格式要求
- 示例
```

---

## 八、Web 服务模块 (src/server/)

### 8.1 Web 服务架构

```
FastAPI 应用
    ↓
┌─────────────────────────────────────┐
│         routes.py (路由层)           │
│  • POST /chat - 创建聊天会话        │
│  • GET /chat/{id} - 获取会话状态    │
│  • WS /ws - WebSocket 连接          │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│    chat_stream.py (业务逻辑层)       │
│  • ChatStreamManager - 会话管理     │
│  • 流式输出处理                      │
│  • 状态同步                          │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│      graph/builder.py (工作流层)     │
│  • 调用 LangGraph 工作流             │
│  • 处理检查点                        │
└─────────────────────────────────────┘
```

### 8.2 流式输出机制

```python
# 流式输出的实现
async def stream_research_results(query: str):
    """流式返回研究结果"""
    graph = create_research_graph()

    # 订阅状态更新
    async for event in graph.astream({"query": query}):
        # 每个节点完成时发送更新
        yield {
            "type": "node_complete",
            "node": event["node"],
            "data": event["data"]
        }

    # 最终结果
    yield {
        "type": "final_report",
        "data": final_report
    }
```

---

## 九、前端架构 (web/)

### 9.1 前端技术栈

```
Next.js 15 (App Router)
    ↓
┌─────────────────────────────────────┐
│         页面层 (app/)                │
│  • /chat - 聊天界面                 │
│  • /history - 历史记录              │
│  • /settings - 设置页面             │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│       组件层 (components/)           │
│  • ChatMessage - 消息组件           │
│  • MarkdownRenderer - 渲染器        │
│  • PlanReview - 计划审核组件        │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│       状态管理 (hooks/)              │
│  • useChat - 聊天状态               │
│  • useWebSocket - WS 连接           │
└─────────────────────────────────────┘
```

### 9.2 前后端通信

```
前端 (Next.js)
    ↓
WebSocket 连接
    ↓
后端 (FastAPI)
    ↓
实时推送更新
    ↓
前端更新 UI
```

---

## 十、扩展机制

### 10.1 自定义智能体

```python
# 添加新智能体的步骤
# 1. 在 src/agents/agents.py 中定义
def create_custom_agent(llm, tools):
    return create_react_agent(
        llm=llm,
        tools=tools,
        prompt=CUSTOM_PROMPT
    )

# 2. 在 src/prompts/ 中添加提示词
CUSTOM_PROMPT = """..."""

# 3. 在工作流中注册
workflow.add_node("custom", custom_node)
```

### 10.2 自定义工具

```python
# 添加新工具的步骤
# 1. 在 src/tools/ 中创建工具类
class CustomTool(BaseTool):
    name = "custom_tool"
    description = "工具描述"

    def _run(self, input: str) -> str:
        # 实现逻辑
        return result

# 2. 注册到智能体
tools = [search_tool, custom_tool]
agent = create_agent(llm, tools)
```

### 10.3 MCP 集成扩展

```yaml
# conf.yaml 中配置 MCP 服务器
MCP_SERVERS:
  github:
    command: npx
    args: ["-y", "@modelcontextprotocol/server-github"]
    env:
      GITHUB_TOKEN: ${GITHUB_TOKEN}
```

---

## 十一、配置管理

### 11.1 配置文件结构

```
配置系统
    ├── conf.yaml - 主配置文件
    │   ├── LLM_MODELS - LLM 配置
    │   ├── SEARCH_CONFIG - 搜索配置
    │   ├── RAG_CONFIG - RAG 配置
    │   └── MCP_SERVERS - MCP 配置
    │
    └── .env - 环境变量
        ├── API Keys
        ├── 数据库连接
        └── 其他敏感信息
```

### 11.2 配置加载流程

```
启动应用
    ↓
加载 .env 文件
    ↓
加载 conf.yaml
    ↓
解析环境变量引用 (${VAR})
    ↓
验证配置完整性
    ↓
创建配置对象
    ↓
传递给各模块
```

---

## 十二、架构设计总结

### 12.1 设计优势

**1. 模块化和可扩展性**
- 清晰的模块边界
- 插件化的工具系统
- 易于添加新智能体和工具

**2. 状态驱动的工作流**
- 基于 LangGraph 的状态机
- 支持检查点和恢复
- 可视化的流程图

**3. 多 LLM 支持**
- 统一的 LLM 接口
- 灵活的模型选择
- 降级和重试机制

**4. 工具抽象**
- 统一的工具接口
- 易于集成新工具
- 支持 MCP 协议

### 12.2 关键技术选型

| 技术 | 选型 | 原因 |
|------|------|------|
| 工作流引擎 | LangGraph | 状态管理、可视化、检查点 |
| LLM 集成 | LiteLLM | 支持 100+ 提供商 |
| Web 框架 | FastAPI | 高性能、异步、类型安全 |
| 前端框架 | Next.js 15 | SSR、App Router、性能优化 |
| 向量数据库 | Milvus/Qdrant | 高性能、易部署 |

### 12.3 模块关系总结

```
核心依赖链：
main.py → graph/builder → graph/nodes → agents → tools/llms

横向协作：
server ←→ graph (Web 服务调用工作流)
agents ←→ prompts (智能体使用提示词)
tools ←→ llms (工具调用 LLM)

配置驱动：
所有模块 ← config.py (统一配置管理)
```

### 12.4 扩展建议

**添加新功能时的建议顺序：**

1. **添加新工具**
   - 在 `src/tools/` 创建工具类
   - 实现 `BaseTool` 接口
   - 注册到相应智能体

2. **添加新智能体**
   - 在 `src/agents/agents.py` 定义智能体
   - 在 `src/prompts/` 添加提示词
   - 在工作流中添加节点

3. **修改工作流**
   - 在 `src/graph/nodes.py` 添加节点函数
   - 在 `src/graph/builder.py` 更新图结构
   - 更新 `src/graph/types.py` 状态定义

4. **集成新 LLM**
   - 在 `conf.yaml` 添加模型配置
   - LiteLLM 自动支持（无需代码修改）

---

## 十三、参考资料

**核心依赖文档：**
- [LangGraph 文档](https://langchain-ai.github.io/langgraph/)
- [LangChain 文档](https://python.langchain.com/)
- [LiteLLM 文档](https://docs.litellm.ai/)
- [FastAPI 文档](https://fastapi.tiangolo.com/)
- [Next.js 文档](https://nextjs.org/docs)

**项目相关：**
- [DeerFlow GitHub](https://github.com/bytedance/deer-flow)
- [配置指南](https://github.com/bytedance/deer-flow/blob/main/docs/configuration_guide.md)
- [MCP 协议](https://modelcontextprotocol.io/)

---

**文档版本：** v1.0
**最后更新：** 2026-02-11
**适用项目版本：** DeerFlow latest










